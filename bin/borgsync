#!/bin/bash
#      _                                                 
#     | |__    ___   _ __  __ _  ___  _   _  _ __    ___ 
#     | '_ \  / _ \ | '__|/ _` |/ __|| | | || '_ \  / __|
#     | |_) || (_) || |  | (_| |\__ \| |_| || | | || (__ 
#     |_.__/  \___/ |_|   \__, ||___/ \__, ||_| |_| \___|
#                         |___/       |___/              
#
# Manage backups/storage on BorgBase, rsync.net, or ssh server
# Usage: borgsync -u
#
# Written 2024-01-14 by Ronald Joe Record <ronaldrecord@gmail.com>
#
# See: https://www.rsync.net/resources/howto/unix.html
# And: https://borgbase.com/
# And: https://www.borgbackup.org/
#
# ========================= Configure =====================================
# Set the remote username and hostname in /etc/borgsync/base
# REMOTE_USER="<rsync.net username>"
# REMOTE_HOST="<host>.rsync.net"
#
# Override any setting in /etc/borgsync/base in ~/.config/borgsync/base
#
# Set and export BORG_PASSPHRASE in the environment
# export BORG_PASSPHRASE="longandcomplexpassphrase"
# ====================== End Configure ====================================
myhost="$(hostname)"
bdir="backups"
mntpt="/mnt/borg"
borg=
cmd=
dryrun=
list=
quota=
recurse=
remove=
src=
tybu=
dudf=
verbose=

usage() {
  printf "\nUsage: borgsync [-b init|check|create|delete|extract|info|list|mount|umount]"
  printf "\n                [-C config] [-c cmd] [-d dir] [-lLn] [-m mnt] [-U user]"
  printf "\n                [-H host] [-qQruvV] [-t base|full|home|logs] folder"
  printf "\nWhere:"
  printf "\n\t-b 'init' initializes a borg backup repository"
  printf "\n\t-b 'check' verifies the consistency of the borg backup repository"
  printf "\n\t-b 'create' creates a borg backup on remote storage"
  printf "\n\t   combine with '-t base|full|home|logs' (default: base)"
  printf "\n\t-b 'delete' deletes the borg backup repository on remote storage"
  printf "\n\t-b 'extract' lists what would be extracted and provides a command to extract"
  printf "\n\t   use the 'folder' argument to provide a pattern to match for extraction"
  printf "\n\t-b 'info' displays detailed information about the borg backup repository"
  printf "\n\t-b 'list' lists all archives in the borg backup repository"
  printf "\n\t-b 'mount' mounts the borg backup repository on ${mntpt}"
  printf "\n\t-b 'umount' unmounts the borg backup repository from ${mntpt}"
  printf "\n\t-C '/path/to/config' specifies the base config file (default: ${CONFIG})"
  printf "\n\t-c 'cmd' runs command 'cmd' on the remote storage host"
  printf "\n\t-d 'dir' specifies a borg backup directory (default: ${bdir})"
  printf "\n\t-l indicates list the contents of the backup folder"
  printf "\n\t-L indicates recursively list the contents of the backup folder"
  printf "\n\t-m 'mnt' specifies the mount point for the borg repo (default: ${mntpt})"
  printf "\n\t-n indicates perform a dry run, don't make any changes"
  printf "\n\t-q indicates see how much space your account uses with the quota/df commands"
  printf "\n\t-Q indicates see how much space your account uses with the quota/df/du commands"
  printf "\n\t-r indicates remove remote backup"
  printf "\n\t-t 'conf' specifies an alternate borgsync config file to use"
  printf "\n\t   '-t fubar' will use the borgsync config file /etc/borgsync/fubar"
  printf "\n\t-v indicates verbose mode"
  printf "\n\t-V displays the borgsync version and exits"
  printf "\n\t-U 'user' sets the remote storage user to 'user'"
  printf "\n\t-H 'host' sets the remote storage host to 'host'"
  printf "\n\t-u displays this usage message and exits\n"
  printf "\nThe 'folder' argument indicates the remote storage folder to sync/list/remove"
  printf "\nWithout arguments borgsync performs the default borg backup\n"
  printf "\nCurrently using ${user}@${host} for ${myhost}\n"
  exit 1
}

info() { printf "\n%s %s\n\n" "$( date )" "$*" >&2; }

install_borg() {
  # Releases:
  #   borg-freebsd64
  #   borg-linux64
  #   borg-macos64
  # Currently borgsync only supports macos and linux
  relname="linux64"
  platform=$(uname -s)
  [ "$platform" == "Darwin" ] && relname="macos64"
  API_URL="https://api.github.com/repos/borgbackup/borg/releases/latest"
  DL_URL=
  DL_URL=$(curl --silent ${AUTH_HEADER} "${API_URL}" \
    | jq --raw-output '.assets | .[]?.browser_download_url' \
    | grep "borg-${relname}$")

  [ "${DL_URL}" ] && {
    printf "\n\tInstalling Borg ..."
    wget --quiet -O /tmp/borg$$ "${DL_URL}"
    chmod 644 /tmp/borg$$
    [ -d /usr/local/bin ] || ${SUDO} mkdir -p /usr/local/bin
    ${SUDO} cp /tmp/borg$$ /usr/local/bin/borg
    ${SUDO} chown root:root /usr/local/bin/borg
    ${SUDO} chmod 755 /usr/local/bin/borg
    ${SUDO} ln -s /usr/local/bin/borg /usr/local/bin/borgfs
    rm -f /tmp/borg$$
    printf " done"
  }
}

borg_check() {
  if [[ -z ${BORG_CHECK_ARGS[@]} ]]; then
    BORG_CHECK_ARGS=(
      --info
    )
  fi

  info "Checking backup"

  ${SUDO} ${BORG} check ${BORG_CHECK_ARGS[@]} ${BORG_REPO} 2>/dev/null
}

borg_init() {
  if [[ -z ${BORG_INIT_ARGS[@]} ]]; then
    BORG_INIT_ARGS=(
      --encryption=repokey-blake2
    )
  fi

  info "Initializing ${BORG_REPO}"
  if [ "${dryrun}" ]; then
    printf "\n${SUDO} ssh ${user}@${host} mkdir -p${verbose} ${myhost}\n"
    printf "\n${SUDO} ${BORG} init ${BORG_INIT_ARGS[@]} ${BORG_REPO}\n"
  else
    ${SUDO} ssh ${user}@${host} mkdir -p${verbose} ${myhost}
    if [ "${verbose}" ]; then
      ${SUDO} ${BORG} init ${BORG_INIT_ARGS[@]} ${BORG_REPO}
    else
      ${SUDO} ${BORG} init ${BORG_INIT_ARGS[@]} ${BORG_REPO} 2>/dev/null
    fi
  fi
  [ "${BORG_PASSPHRASE}" ] || {
    printf "\nExport your passphrase with:"
    printf "\n\texport BORG_PASSPHRASE='your-pass-phrase'\n"
  }
}

borg_create() {
  [ "${BORG_PASSPHRASE}" ] || {
    printf "\nWARNING: No Borg passphrase detected."
    printf "\nExport your passphrase in the environment variable:"
    printf "\n\texport BORG_PASSPHRASE='your-pass-phrase'\n"
  }

  trap 'echo $( date ) Backup interrupted >&2; exit 2' INT TERM

  info "Starting backup"

  if [ "${dryrun}" ]; then
    BORG_CREATE_ARGS+=( --dry-run )
  else
    BORG_CREATE_ARGS+=( --stats )
  fi
  [ "${verbose}" ] && BORG_CREATE_ARGS+=( --verbose )

  EXCLUDE_ARGS=()
  for EXCLUDE in "${EXCLUDES[@]}"; do
    EXCLUDE_ARGS+=( --exclude "${EXCLUDE}" )
  done
  INCLUDE_ARGS=()
  for INCLUDE in "${INCLUDES[@]}"; do
    INCLUDE_ARGS+=( --pattern=+${INCLUDE} )
  done

  ${SUDO} ${BORG} create                 \
    "${BORG_CREATE_ARGS[@]}"             \
    "${EXCLUDE_ARGS[@]}"                 \
    "${INCLUDE_ARGS[@]}"                 \
    "${BORG_REPO}"::'{hostname}-{now}'   \
    "${PATHS[@]}"

  backup_exit=$?

  info "Pruning repository"
  if [[ -z ${BORG_PRUNE_ARGS[@]} ]]; then
    BORG_PRUNE_ARGS=(
      --info
      --list
    )
  fi
  if [ "${dryrun}" ]; then
    BORG_PRUNE_ARGS+=( --dry-run )
  else
    BORG_PRUNE_ARGS+=( --stats )
  fi

  ${SUDO} ${BORG} prune \
    "${BORG_PRUNE_ARGS[@]}" \
    --glob-archives '{hostname}-*' \
    --keep-hourly=${KEEP_HOURLY:-0} \
    --keep-daily=${KEEP_DAILY:-0} \
    --keep-weekly=${KEEP_WEEKLY:-0} \
    --keep-monthly=${KEEP_MONTHLY:-0} \
    --keep-yearly=${KEEP_YEARLY:-0} \
    "${BORG_REPO}"

  prune_exit=$?

  # free repo disk space by compacting segments
  info "Compacting repository"

  ${SUDO} ${BORG} compact

  compact_exit=$?

  # use highest exit code as global exit code
  global_exit=$(( backup_exit > prune_exit ? backup_exit : prune_exit ))
  global_exit=$(( compact_exit > global_exit ? compact_exit : global_exit ))

  if [ ${global_exit} -eq 0 ]; then
    info "Backup, Prune, and Compact finished successfully"
  elif [ ${global_exit} -eq 1 ]; then
    info "Backup, Prune, and/or Compact finished with warnings"
  else
    info "Backup, Prune, and/or Compact finished with errors"
  fi

  exit ${global_exit}
}

load_config() {
  [ -f "${CONFIG}" ] && {
    source "${CONFIG}"
  }
  [ -f "${MYCONF}" ] && {
    source "${MYCONF}"
  }
  [ "${BORG}" ] && [ -x "${BORG}" ] || BORG=$(command -v borg)
  [ "${BORG}" ] || {
    [ -x /usr/local/bin/borg ] && BORG="/usr/local/bin/borg"
  }
  [ "${BORG}" ] || {
    install_borg
    BORG=$(command -v borg)
  }
}

init_config() {
  [ "${REMOTE_USER}" ] && user="${REMOTE_USER}"
  [ "${REMOTE_HOST}" ] && host="${REMOTE_HOST}"
  [ "${BACK_HOST}" ] && myhost="${BACK_HOST}"
  [ "${BACK_DIR}" ] && bdir="${BACK_DIR}"

  [ "${BORG_REMOTE_PATH}" ] || BORG_REMOTE_PATH=/usr/loca/bin/borg1/borg1
  export BORG_REMOTE_PATH
  [ "${BORG_REPO}" ] || BORG_REPO=${user}@${host}:${myhost}/${bdir}
  export BORG_REPO
}

if [ "${GH_TOKEN}" ]; then
  AUTH_HEADER="-H \"Authorization: Bearer ${GH_TOKEN}\""
else
  AUTH_HEADER=
fi
export PATH="/usr/local/bin:$PATH"
[ -x ${HOME}/.local/bin/borgsync ] && {
  export PATH="$HOME/.local/bin:$PATH"
}

CONFIG="/etc/borgsync/base"
MYCONF="${HOME}/.config/borgsync/base"

VERSION="unknown"
RELEASE="unknown"
[ -f /etc/borgsync/VERSION ] && . /etc/borgsync/VERSION

load_config
init_config

[ $# -eq 0 ] && borg="create"
while getopts ":b:c:C:d:hHlLm:nqQrt:vVuU" flag; do
  case $flag in
    b)
      borg="${OPTARG}"
      ;;
    c)
      cmd="${OPTARG}"
      ;;
    C)
      [ -f "${OPTARG}" ] || {
        printf "\nERROR: Specified base config file ${OPTARG} does not exist\n"
        exit 1
      }
      CONFIG="${OPTARG}"
      load_config
      ;;
    d)
      BACK_DIR="${OPTARG}"
      bdir="${BACK_DIR}"
      ;;
    H)
      REMOTE_HOST="${OPTARG}"
      host="${REMOTE_HOST}"
      ;;
    l)
      list=1
      ;;
    L)
      list=1
      recurse=1
      ;;
    m)
      mntpt="${OPTARG}"
      ;;
    n)
      dryrun="nv"
      ;;
    q)
      quota=1
      ;;
    Q)
      quota=1
      dudf=1
      ;;
    r)
      remove=1
      ;;
    t)
      tybu="${OPTARG}"
      ;;
    U)
      REMOTE_USER="${OPTARG}"
      user="${REMOTE_USER}"
      ;;
    v)
      verbose="v"
      ;;
    V)
      printf "\nBorgsync version ${VERSION} release ${RELEASE}\n"
      exit 0
      ;;
    h|u)
      usage
      ;;
    \?)
      echo "Invalid option: $flag"
      usage
      ;;
  esac
done
shift $(( OPTIND - 1 ))

[ "${tybu}" ] && {
  if [ -f /etc/borgsync/${tybu} ]; then
    source /etc/borgsync/${tybu}
    [ -f "${HOME}/.config/borgsync/${tybu}" ] && {
      source "${HOME}/.config/borgsync/${tybu}"
    }
  else
    if [ -f "${HOME}/.config/borgsync/${tybu}" ]; then
      source "${HOME}/.config/borgsync/${tybu}"
    else
      printf "\nERROR: specified backup type ${tybu} does not exist in /etc/borgsync/"
      printf "\nExiting\n"
      exit 1
    fi
  fi
}
init_config

[ "${user}" == "<your_remote_user>" ] || \
[ "${host}" == "<your_remote_host>" ] || \
[ "${user}" == "<your_borgbase_remote_user>" ] || \
[ "${host}" == "<your_borgbase_remote_host>" ] && {
  printf "\nERROR: user and host variables must be set to remote storage account values\n"
  printf "\nSet REMOTE_USER and REMOTE_HOST in /etc/borgsync/base\n"
  exit 1
}

uid=$(id -u)
gid=$(id -g)
SUDO="sudo -E"
if [ "${EUID}" ]; then
  [ ${EUID} -eq 0 ] && SUDO=
else
  [ ${uid} -eq 0 ] && SUDO=
fi

[ "${BORG_PASSPHRASE}" ] || {
  [ -f ${HOME}/.private ] && source ${HOME}/.private
}

folderargs=
[ "$1" ] && folderargs="$*"

[ "${cmd}" ] && {
  printf "\nCommand: ${cmd}\n"
  if [ "${dryrun}" ]; then
    printf "\nssh ${user}@${host} ${cmd}\n"
  else
    ssh ${user}@${host} ${cmd}
  fi
  exit 0
}

[ "${quota}" ] && {
  if [ "${dryrun}" ]; then
    printf "\nCommand: quota\n\n"
    printf "\n\nCommand: df -h\n\n"
    [ "${dudf}" ] && {
      printf "\n\nCommand: du -h -d 0 *\n\n"
    }
  else
    printf "\nCommand: quota\n\n"
    ssh ${user}@${host} quota
    printf "\n\nCommand: df -h\n\n"
    ssh ${user}@${host} df -h
    [ "${dudf}" ] && {
      printf "\n\nCommand: du -h -d 0 *\n\n"
      ssh ${user}@${host} du -h -d 0 \*
    }
  fi
  exit 0
}

[ "${borg}" ] && {
  have_borg=$(type -p borg)
  [ "${have_borg}" ] || {
    install_borg
    BORG=$(command -v borg)
  }
  case "${borg}" in
    init|initialize)
      borg_init
      ;;
    check|verify)
      borg_check
      ;;
    backup|create)
      [ "${BORG_PASSPHRASE}" ] || {
        printf "\nWARNING: No Borg passphrase detected."
        printf "\nExport your passphrase in the environment variable:"
        printf "\n\texport BORG_PASSPHRASE='your-pass-phrase'\n"
      }
      BORG_CHECK_ARGS=(
        --repository-only
      )
      borg_check
      [ $? -eq 2 ] && borg_init
      borg_create
      ;;
    delete|remove)
      info "Deleting repository ${BORG_REPO}"
      ${SUDO} ${BORG} delete ${BORG_REPO}
      info "Compacting repository ${BORG_REPO}"
      ${SUDO} ${BORG} compact ${BORG_REPO} 2>/dev/null
      ;;
    extract|restore)
      printf "\nArchives in ${BORG_REPO}:\n"
      ${SUDO} ${BORG} list ${BORG_REPO} 2>/dev/null
      archive=$(${SUDO} ${BORG} list --sort timestamp  --format '{time}{TAB}{name}{NEWLINE}' ${BORG_REPO} | grep -v '\.checkpoint$' | tail -1 |  cut -f 2)
      if [ "${archive}" ]; then
        printf "\nLast successful archive in ${BORG_REPO}:\n\t${archive}\n"
        printf "\nList ${archive} with the command:\n"
        printf "\n${SUDO} ${BORG} extract --dry-run --list ${BORG_REPO}::${archive} ${folderargs}\n"
        printf "\nDue to the --dry-run and --list arguments this won't actually restore any files.\n"
        printf "\nExtract ${archive} to the current directory with:\n"
        printf "\n${SUDO} ${BORG} extract --list ${BORG_REPO}::${archive} ${folderargs}\n"
      else
        printf "\nCould not locate an archive in ${BORG_REPO}:\n"
      fi
      [ "${folderargs}" ] && {
        printf "\nThe last part of the command gives the path you're looking to restore."
        printf "\nIf you pass no paths, then all the data will be restored. To extract a"
        printf "\nparticular directory without its full path, add --strip-components n,"
        printf "\nwith n being the number of directories you would like to be stripped.\n"
      }
      ;;
    info|information)
      printf "\nInfo for borg repository:"
      printf "\n========================"
      printf "\nRepository name: ${BORG_REPO}\n"
      ${SUDO} ${BORG} info ${BORG_REPO} 2>/dev/null
      archive=$(${SUDO} ${BORG} list --sort timestamp  --format '{time}{TAB}{name}{NEWLINE}' ${BORG_REPO} | grep -v '\.checkpoint$' | tail -1 |  cut -f 2)
      if [ "${archive}" ]; then
        printf "\nInfo for last successful archive:"
        printf "\n================================\n"
        ${SUDO} ${BORG} info ${BORG_REPO}::${archive} 2>/dev/null
      else
        printf "\nCould not locate an archive in ${BORG_REPO}:\n"
      fi
      ;;
    list|show)
      ${SUDO} ${BORG} list ${BORG_REPO} 2>/dev/null
      ;;
    mount)
      [ -d ${mntpt} ] || ${SUDO} mkdir -p ${mntpt}
      ${SUDO} chown ${uid}:${gid} ${mntpt}
      ${SUDO} ${BORG} mount ${BORG_REPO} ${mntpt} 2>/dev/null
      ;;
    umount|unmount)
      ${SUDO} ${BORG} umount ${mntpt}
      ;;
    *)
      usage
      ;;
  esac
  exit 0
}

[ "${folderargs}" ] || {
  if [ "${list}" ]; then
    src="/."
  else
    printf "\nDirectory argument required to upload or remove folders\n"
    printf "\nCurrent remote storage ${myhost} directory listing:\n"
    ssh ${user}@${host} ls -la "${myhost}"
    usage
  fi
}
[ "${list}" ] || {
  [ "${remove}" ] || {
    [ "${quota}" ] || {
      [ -d "${folderargs}" ] || {
        printf "\nERROR: $1 does not exist or is not a directory\n"
        usage
      }
    }
  }
}

[ "${src}" ] || src="$(realpath "${folderargs}" | sed -e "s%/$%%")"

if [ "${list}" ]; then
  if [ "${recurse}" ]; then
    if [ "${dryrun}" ]; then
      printf "\nssh ${user}@${host} ls -lRa ${myhost}${src}\n"
    else
      ssh ${user}@${host} ls -lRa "${myhost}${src}"
    fi
  else
    if [ "${dryrun}" ]; then
      printf "\nssh ${user}@${host} ls -la ${myhost}${src}\n"
    else
      ssh ${user}@${host} ls -la "${myhost}${src}"
    fi
  fi
else
  if [ "${remove}" ]; then
    if [ "${dryrun}" ]; then
      printf "\nssh ${user}@${host} rm -rf${verbose} ${myhost}${src}\n"
    else
      ssh ${user}@${host} rm -rf${verbose} "${myhost}${src}"
    fi
  else
    # Create directory if it does not exist
    top=$(dirname ${myhost}${src})
    if [ "${dryrun}" ]; then
      printf "\nssh ${user}@${host} mkdir -p${verbose} ${myhost}\n"
      printf "\nssh ${user}@${host} mkdir -p${verbose} ${top}\n"
    else
      ssh ${user}@${host} mkdir -p${verbose} ${myhost}
      ssh ${user}@${host} mkdir -p${verbose} ${top}
    fi

    # Backup specified directory
    rsync -aHh${dryrun}${verbose} \
      --delete \
      --delete-excluded \
      --exclude='.DS_Store' \
      "${src}/" \
      ${user}@${host}:"${myhost}${src}"
    [ "${dryrun}" ] || {
      printf "\nListing of remote storage backup folder ${myhost}${src}:\n"
      ssh ${user}@${host} ls -a "${myhost}${src}"
    }
  fi
fi
